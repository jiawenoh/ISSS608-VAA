---
title: "Take Home Exercise 2"
subtitle: " Mini Case 2 of Vast Challenge 2023"
author: "Oh Jia Wen"
date: "5/24/2023"
date-modified: "5/24/2023"
execute: 
  echo: true
  eval: true
  warning: false
---

# 1. OVERVIEW

FishEye International is collaborating with the country of Oceanus to identify companies who could potentially engaged in illegal, unreported, and unregulated (IUU) fishing. FishEye has transformed import/export data into a knowledge graph.

The country of Oceanus has sought FishEye International's help in identifying companies possibly engaged in illegal, unreported, and unregulated (IUU) fishing.

With reference to [Mini-Challenge 2](https://vast-challenge.github.io/2023/MC2.html) of [VAST Challenge 2023](https://vast-challenge.github.io/2023/) and by using appropriate **static and interactive statistical graphics** methods, you are required to help FishEye identify companies that may be engaged in illegal fishing?

## 1.1 The Task

In this take-home exercise...

# 2. Datasets

The trade data is stored in *mc2_challenge_graph.json* file with a time period of 7 years from the time period 2028 to 2024. It includes a bundles with 12 types of marine species, ranging from Carp, Shark, to Tuna.

# 3. Data Preparation

## 3.1 Install R-packages

Using p_load() of pacman package to load and install the following libraries:

-   `jsonlite` : To Import Data from JSON File into R

-   `lubridate` : To Convert Date and Time

-   `visNetwork`: For Network Visualization

-   `tidyverse`: A collection of R packages use in everyday data analyses. It is able to support data science, data wrangling, and analysis.

-   `ggplot2`:By

-   `hrbrthemes`: For Additional Themes, and Utilities for 'ggplot2' (might not use)

-   `heatmaply`:

-   `treemap`:

-   `devtools`: For the installing for `d3treeR`

`igraph`: for exploring the network

`ggstatsplot`: for creating graphics with details from statistical tests included and its plot

`RColorBrewer`:

`scales` : check at EOD

```{r}
pacman :: p_load (jsonlite, lubridate, tidygraph, ggraph, visNetwork, tidyverse,
                  igraph,ggplot2,heatmaply,hrbrthemes,scales,treemap,devtools,
                  ggstatsplot,RColorBrewer, knitr)

options(scipen = 999)
```

## 3.2 Importing Data

There are 13 JSON files that will be imported into R the `fromJSON` function from `jsonlite`. The code chunk below shows the knowledge graph FishEye created from trade records.

```{r}
MC2_challenge <- fromJSON("data/mc2_challenge_graph.json")
```

```{r}
#| code-fold: true
MC2_carp <- fromJSON("data/bundles/carp.json")
MC2_catfish <- fromJSON("data/bundles/catfish.json")
MC2_chub_mackerel <- fromJSON("data/bundles/chub_mackerel.json")
MC2_cod2 <- fromJSON("data/bundles/cod2.json")
MC2_herring <- fromJSON("data/bundles/herring.json")
MC2_lichen <- fromJSON("data/bundles/lichen.json")
MC2_mackerel <- fromJSON("data/bundles/mackerel.json")
MC2_pollock <- fromJSON("data/bundles/pollock.json")
MC2_salmon_wgl <- fromJSON("data/bundles/salmon_wgl.json")
MC2_salmon <- fromJSON("data/bundles/salmon.json")
MC2_shark <- fromJSON("data/bundles/shark.json")
MC2_tuna <- fromJSON("data/bundles/tuna.json")
```

## 3.3 Create Tibble Dataframe

```{r}
MC2_challenge_nodes <-as_tibble(MC2_challenge$nodes) %>%
  select(id,shpcountry,rcvcountry)
MC2_challenge_edges <-as_tibble(MC2_challenge$links) %>%
  select(source,target,arrivaldate, hscode,valueofgoods_omu, 
         volumeteu, weightkg, valueofgoodsusd)
```

```{r}
#| code-fold: true

#1_fish type :carp
MC2_carp_nodes <-as_tibble(MC2_carp$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_carp_edges <-as_tibble(MC2_carp$links) %>%
  relocate(8,9,7,6)

#2_fish type: catfish
MC2_catfish_nodes <-as_tibble(MC2_catfish$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_catfish_edges <-as_tibble(MC2_catfish$links) %>%
  relocate(6,7,5,4)

#3_fish type: chub_mackerel
MC2_chub_mackerel_nodes <-as_tibble(MC2_chub_mackerel$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_chub_mackerel_edges <-as_tibble(MC2_chub_mackerel$links) %>%
  relocate(8,9,7,6)

#4_fish type: cod2
MC2_cod2_nodes <-as_tibble(MC2_cod2$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_cod2_edges <-as_tibble(MC2_cod2$links) %>%
  relocate(8,9,7,6)

#5_fish type: herring
MC2_herring_nodes <-as_tibble(MC2_herring$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_herring_edges <-as_tibble(MC2_herring$links) %>%
  relocate(7,8,6,5,1,2,9,3,4)

#6_fish type: lichen
MC2_lichen_nodes <-as_tibble(MC2_lichen$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_lichen_edges <-as_tibble(MC2_lichen$links) %>%
    relocate(7,8,6,5,1,2,9,3,4)

#7_fish type: mackerel
MC2_mackerel_nodes <-as_tibble(MC2_mackerel$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_mackerel_edges <-as_tibble(MC2_mackerel$links) %>%
    relocate(6,7,5,4)

#8_fish type: pollock
MC2_pollock_nodes <-as_tibble(MC2_pollock$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_pollock_edges <-as_tibble(MC2_pollock$links) %>%
    relocate(8,9,7,6)

#9_fish type: salmon_wgl
MC2_salmon_wgl_nodes <-as_tibble(MC2_salmon_wgl$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_salmon_wgl_edges <-as_tibble(MC2_salmon_wgl$links) %>%
  relocate(7,8,6,5,1,2,9,3,4)

#10_fish type: salmon
MC2_salmon_nodes <-as_tibble(MC2_salmon$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_salmon_edges <-as_tibble(MC2_salmon$links) %>%
  relocate(8,9,7,6)

#11_fish type: shark
MC2_shark_nodes <-as_tibble(MC2_shark$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_shark_edges <-as_tibble(MC2_shark$links) %>%
    relocate(7,8,6,5,1,2,9,3,4)

#12_fish type: tuna
MC2_tuna_nodes <-as_tibble(MC2_tuna$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_tuna_edges <-as_tibble(MC2_tuna$links) %>%
  relocate(5,6,4,3)
```

## 3.4 Concatenate Tibble Dataframe

Among the 12 files, there are 3 data frames which have 7 variables whereas the rest have 9 variables. As such, `bind_rows()` - a function from the `dplyr` package within the `tidyverse` is used.

```{r}
combined_edges <- bind_rows(MC2_carp_edges,MC2_chub_mackerel_edges,
                        MC2_cod2_edges,MC2_herring_edges,MC2_lichen_edges,
                        MC2_pollock_edges,MC2_salmon_wgl_edges,
                        MC2_salmon_edges,MC2_shark_edges, 
                        MC2_catfish_edges,MC2_mackerel_edges,MC2_tuna_edges)
```

::: callout-Tip
Catfish, Mackerel, and Tuna have 7 variables while other fishes have 9 variables. It is better to concatenate with the use `blind_rows` instead of `rbind()` as the latter requires an exact match in the numbers of columns.
:::

```{r}
combined_nodes <- bind_rows(MC2_carp_nodes,MC2_catfish_nodes,
                            MC2_chub_mackerel_nodes,MC2_cod2_nodes,
                            MC2_herring_nodes, MC2_lichen_nodes,
                            MC2_mackerel_nodes, MC2_pollock_nodes, 
                            MC2_salmon_wgl_nodes,MC2_salmon_nodes,
                            MC2_shark_nodes, MC2_tuna_nodes)
```

## Creating a Master ID data frame

```{r}
#| code-fold: true

MC2_id_list <- MC2_challenge_nodes %>%
  rename(label = id) %>%
  mutate(
    trade_status = case_when(
    !is.na(shpcountry) & !is.na(rcvcountry) ~ "Import & Export",
    !is.na(shpcountry) ~ "Export",
    !is.na(rcvcountry) ~ "Import",
    is.na(shpcountry) | is.na(rcvcountry) ~"Unknown"
  )) 

MC2_id_list <- MC2_id_list %>%
  select(label,trade_status,shpcountry, rcvcountry)

#create new df and add new column called trade_status
MC2_id_list_vis <- MC2_challenge_nodes %>%
  rename(label = id) %>%
  mutate(id = as.character(1:nrow(MC2_challenge_nodes)),
    trade_status = case_when(
    !is.na(shpcountry) & !is.na(rcvcountry) ~ "Import & Export",
    !is.na(shpcountry) ~ "Export",
    !is.na(rcvcountry) ~ "Import",
    is.na(shpcountry) | is.na(rcvcountry) ~"Unknown"
  )) %>%
  filter(!is.na(trade_status))

#reorder the columns 
MC2_id_list_vis <- MC2_id_list_vis %>%
  select(id,label, trade_status,shpcountry, rcvcountry)

#create df to identify companies in target column that are not in the nodes 
ID_target <- MC2_challenge_edges %>%
  filter(!(target %in% MC2_id_list$label)) %>%
  distinct(target) %>%
  #rename to match names in nodes df
  rename(id = target) %>%
  #dummy columns are created to bind rows together
  mutate(dataset = NA, shpcountry = NA, rcvcountry = NA)

#create df to identify companies in source column that are not in the nodes 
ID_source <- MC2_challenge_edges %>%
  filter(!(source %in% MC2_id_list$label)) %>%
  distinct(source) %>%
  rename(id = source) %>%
  mutate(dataset = NA, shpcountry = NA, rcvcountry = NA)

#append the distinct companies into the nodes 
MC2_challenge_nodes <- MC2_challenge_nodes %>%
  rbind(ID_target) %>%
  rbind(ID_source)

#output of ID nodes that are not in Master list
nrow(ID_source)
nrow(ID_target)
```

There are 0 companies on the `target` column that are not included in the list. Meanwhile, there are no data available in the `source` column that are not in the list.

The `!is.na()` functions help to check for non-missing values in the specified column. In this combined_nodes data frame, the ID only corresponds to either the shipping country or the receiving country. Therefore, it is further segregated into import and export.

```{r}
any(is.na(MC2_id_list))
```

## 3.5 Data Wrangling

```{r}
#| code-fold: true

#revise the data format for arrivaldate and hscode 
MC2_challenge_edges<- MC2_challenge_edges %>%
  rename(sourcelabel = source, targetlabel = target) %>%
  mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode),
         year = year(arrivaldate))

#to append correspoinding id through left_join 
MC2_challenge_edges <- MC2_challenge_edges %>%
  left_join(MC2_id_list_vis, by = c("sourcelabel" = "label")) %>%
  rename(source = id) %>%
  left_join(MC2_id_list_vis, by = c("targetlabel" = "label")) %>%
  rename(target = id) %>%
  relocate(10,14)
  
```

```{r}
combined_edges_cleaned<- combined_edges %>%
  mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

combined_edges_cleaned
```

#### 3.5.1 Data Wrangling for Bundles

```{r}
#| code-fold: true

#1_fish type: carp
MC2_carp_edges_cleaned <- MC2_carp_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#2_fish type: catfish
MC2_catfish_edges_cleaned <- MC2_catfish_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#3_fish type: chub_mackerel
MC2_chub_mackerel_edges_cleaned <- MC2_chub_mackerel_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#4_fish type: cod2
MC2_cod2_edges_cleaned <- MC2_cod2_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#5_fish type: herring
MC2_herring_edges_cleaned <- MC2_herring_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#6_fish type: lichen
MC2_lichen_edges_cleaned <- MC2_lichen_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#7_fish type: mackerel
MC2_mackerel_edges_cleaned <- MC2_mackerel_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))
#8_fish type: pollock
MC2_pollock_edges_cleaned <- MC2_pollock_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#9_fish type: salmon_wgl
MC2_salmon_wgl_edges_cleaned <- MC2_salmon_wgl_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#10_fish type: salmon
MC2_salmon_edges_cleaned <- MC2_salmon_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#11_fish type: shark
MC2_shark_edges_cleaned <- MC2_shark_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#12_fish type: tuna
MC2_tuna_edges_cleaned <- MC2_tuna_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))
```

::: {.callout-caution title="Important"}
HS code, also known as The Harmonized System are alphanumeric codes used for classifying goods for international trade and customs purposes. In this exercise, the HS code does not correspond to the respective goods.
:::

Weights: Median = 2 , Mean = 22 , Min = 1, Max, 47134

```{r}
combined_edges_rev <- combined_edges %>%
  group_by(source,target,generated_by) %>%
  summarize(weight = n()) %>%
  filter( source!=target) %>%
  filter(weight >1) %>%
  ungroup ()
```

```{r}
combined_nodes_rev <-MC2_id_list %>%
  filter(label %in% combined_edges_rev$source | 
           label %in% combined_edges_rev$target)
```

```{r}
MC2_import <- tbl_graph(nodes = combined_nodes_rev,
                        edges = combined_edges_rev,
                        directed = TRUE)

MC2_import
```

```{r}
MC2_import %>%
  activate(edges) %>%
  arrange(desc(weight))
```

```{r}
set_graph_style()

fishes <- ggraph(MC2_import, layout = "nicely") +
  geom_node_point(aes(color = trade_status), size =2) +
  scale_edge_width(range =c(0.1,5)) +
  geom_edge_link(aes(width = weight, color = generated_by), alpha = 0.2)

fishes
```

# 4. Distribution of transactions

In this section, we will create plots with interactivity to study and explore the data from the knowledge graph. The plots are created with the use of `heatmaply`,`visNetwork`, and `igraph`packages.

## 4.1 Number of Transactions by Year and Month

Heatmap is created to provide a graphical representation to the transactions. It uses a system of color-coding to represent different values. `[RColorBrewer]` package is used to include sequential palettes *"Blues"* showing progress from low to high (gradient).

As fishing might occurs on a seasonality basis, we created an additional column called *month* before grouping it by *year and month*. To create an interactive heatmap, data frame are transpose through `pivot_wider` before converting it to matrix with the `as.matrix` function. Thereafter, `[heatmaply]` package is used.

```{r}
#| code-fold: true

#aggregate to determine transactions count by year and month 
transaction_counts_by_year <- MC2_challenge_edges %>%
  mutate(month = round(month(arrivaldate))) %>%
  group_by(year, month) %>%
  summarise(count = n())

#transpose df by using pivot_wider
pivoted_data <- transaction_counts_by_year %>%
  pivot_wider(names_from = year, values_from = count) %>%
  #remove the month column
  select(2:8)

#convert pivoted_data into a matrix
heatmap_data <- as.matrix(pivoted_data)

#create interactive heatmap without dendrogram
heatmaply(heatmap_data, dendrogram = "none",
          xlab = "Year", ylab = "Month",
          main = "Number of Transactions by Year and Month",
          scale = "none",
          grid_color = "white",
          grid_width = 0.00001,
          titleX = FALSE,
          hide_colorbar =  FALSE,
          label_names = c("Month:", "Year: ", "No. of Transactions:"),
          fontsize_row = 10, fontsize_col = 10,
          colors = "Blues",
          labCol = colnames(heatmap_data),
          labRow = rownames(heatmap_data),
          plot_method = "plotly")
```

**Observations:**

-   On a yearly basis, the volume of trade is decreasing at a decreasing rate. It peaks around 2028-2030 with the highest time period, occurring in 2030.

-   March seems to be a period with low transactions. However, it reaches a record on Mar 2030, with the highest volume of transactions in the seven years time period.

## 4.2 Trade flow of Organizations with above 30 transactions in Mar 2023

Noting that Mar 2030 has a record high volume, we would like to examine the trade flow of the organizations in this time frame. We start off by creating a new edges and nodes data frame. The edges are created by aggregating it from the the master edges file `MC2_challenge_edges`.

We will be using the `[dpylr]` package to create **`MC2_2030_Mar_edges`**:

-   `mutate()`: to add additional column called **month**

-   `filter()`: is used to filter for **year = 2030** and **month = 3**

-   `group_by` is used to aggregate it by **hscode** and **year**

-   `summarize()` is used to compute the **weight** and **median_weight** of goods

-   `filter()` is used to remove matching name in source and target and to filter for transactions with above 30 counts. This brings up to \~200 rows.

-   `rename()` is used to change the title of the column

Thereafter, we create **`MC2_2030_Mar_nodes`** by filtering out the distinct ID that are in the source and label column from the master ID data frame, `MC2_id_list_vis` .

```{r}
#| code-fold: true

#create edges df for transactions from Mar 2030
MC2_2030_Mar_edges <- MC2_challenge_edges %>%
  mutate(month = round(month(arrivaldate))) %>%
  filter(year == "2030" & month =="3") %>%
  group_by(source, target, hscode) %>%
  summarize(weight = n()) %>%
  filter(source !=target) %>%
  filter(weight >29) %>% #keep ~200 rows 
  rename(from = source, to = target) %>%
  select(1,2,4,3) %>% #relocate weight to 3rd column 
  ungroup()

#create nodes df for transactions from Mar 2030
MC2_2030_Mar_nodes <- MC2_id_list_vis %>%
  filter(id %in% MC2_2030_Mar_edges$from | id %in% MC2_2030_Mar_edges$to) %>%
  distinct() 

```

In the code chunk below, we compute the centrality between the nodes, by using the `graph_from_data_frame` function from the `[igraph]` package. As seen from the output below, the top row represents the ID of the organization while the bottom row represents their score. Given that the result of the betweenness centrality is not significant, we will would look into the degree centrality.

```{r}
#create igraph object 
g <- graph_from_data_frame(d=MC2_2030_Mar_edges, 
                           vertices=MC2_2030_Mar_nodes, directed=TRUE) 

#compute betweeness centrality 
betweenness_centrality <- betweenness(g)
MC2_2030_Mar_nodes$betweenness_centrality <-
  betweenness_centrality[as.character(MC2_2030_Mar_nodes$id)]

#output for top results
betweenness_centrality_tb <-head(sort(betweenness_centrality, decreasing=TRUE))

```

After the data preparation, `visNetwork` is used to plot the plot the interactive network graph with the `Fruchterman and Reingold` layout. Additionally, the graph uses three colors tone from the diverging palettes scheme to color-code the nodes based on degree centrality. It ranges from red - yellow - blue.

```{r}
#| code-fold: true

#compute degree centrality 
degree_centrality <- degree(g)
MC2_2030_Mar_nodes$degree_centrality <- 
  degree_centrality[as.character(MC2_2030_Mar_nodes$id)]

#compute closeness centrality 
closeness_centrality <- closeness(g, normalized=TRUE)
MC2_2030_Mar_nodes$closeness_centrality <- 
  closeness_centrality[as.character(MC2_2030_Mar_nodes$id)]

#add diverging palettes scheme to nodes based on degree centrality
colors <- colorRampPalette(brewer.pal(3, "RdYlBu"))(3) # use three colors 
MC2_2030_Mar_nodes <- MC2_2030_Mar_nodes %>%
  mutate(shape="dot", shadow=TRUE,  
         title=trade_status, # hover for trade_status
         label=label, # add labels on nodes
         size=20, # set size of nodes
         borderWidth=1, #set border width of nodes
         color.background=colors[degree_centrality], #set color
         color.border="grey") #set border color 

#plot network graph 
visNetwork(MC2_2030_Mar_nodes, MC2_2030_Mar_edges, 
            main ="Trade flow of Organizations  
           <br>with above 30 transactions in Mar 2023<br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE,
             selectedBy ="degree_centrality") %>%
  visEdges(arrows = "to") %>% #indicate direction 
  visLayout(randomSeed = 123) %>%
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

::: {.callout-note title="Note about visNetwork" collapse="true"}
## Note about visNetwork

`visIgraphLayout` is used to compute coordinates. In the example above, the *Fruchterman and Reingold* layout is used.

`visOptions` is an options for network visualization. We highlighted the nearest when clicking a node, a dropdown list for ID, a dropdown list by degree of centrality.

`visEdges` is edges options. We includes arrow to indicate direction.

`visLayout` is an layout options. `randomSeed` is included for the layout to remain the same every time.

`addFontAwesome` is used to add icons to the network.

`visInteraction` is used for network visualization interaction.

The default setting as as follows:

1.  `dragNodes` : IF TRUE, nodes can be dragged around by user.

2.  `dragView` : If TRUE, view can be dragged around by user.

3.  `zoomView` : If TRUE, user can zoom in.

4.  `navigationButtons`: If FALSE, navigation buttons are not on the network graph
:::

**Observations:**

-   Organizations who received goods (imports) have higher degree of centrality. hai dan Corporation Wharf has the highest degree of 19.

-   Majority of the organizations have low degree of centrality.

## Statistical Plot of Degree Centrality against Trade Status

```{r}

ggbetweenstats(data = MC2_2030_Mar_nodes,
       x= trade_status, y= degree_centrality, type ="np",
       xlab= "Trade Status", ylab = "Degree Centrality",
       title = "Comparison of Degree Centrality across Trade Status",
       pairwise.comparisons = TRUE, pairwise.display ="s", conf.level = 0.95
       )

```

# Distribution of Median Weight by hscode and year

A `treemap` displays hierarchical data as a set of nested rectangles, where each group is represented by an area that it proportional to its value. We would like to examine the distribution by **hscode** and **year.**

As per section 3.1, the `[devtools]` package have been loaded. Thereafter, we install the package found in github *(highlighted in green)* by using the code and loading the `d3treeR` package.

```{r}
#install_github("timelyportfolio/d3treeR")
library(d3treeR)
```

We will aggregate from `MC2_challenge_edges` data frame by using the `[dpylr]` package:

-   `group_by` is used to aggregate it by **hscode** and **year**

-   `summarize()` is used to compute the **weight** and **median_weight** of goods

-   `arrange(desc())` to sort weight in descending order

-   `MC2_hscode_weight[1:100,]` to retrieve the first 100 rows

*(We are only interested in the highly utilized hscode)*

We build our treemap by inputting our aggregated data frame (`MC2_hscode_weight`) into the `treemap()` function and saved it as an object called **it.** Thereafter, the `d3tree` function from the `[d3treeR]` package is used to build our interactive treemap.

```{r}
#| code-fold: true
#| fig-width: 12
#| fig-height: 6
#| fig.show: hide

#aggregate into new df by hscode and year before sorting in descending order 
MC2_hscode_weight <- MC2_challenge_edges %>%
  group_by(hscode,year) %>%
  summarize(weight = n(),
            median_weight = median(weightkg)) %>%
  arrange(desc(weight)) 

#retrieve the first 100 rows
MC2_hscode_weight <- MC2_hscode_weight[1:100,]

#treemap saved under 'it' object 
it <- treemap(MC2_hscode_weight,
        index=c("hscode","year"),
        vSize="weight",
        vColor="median_weight",
        type ="value",
        algorithm = "pivotSize",
        sortID = "weight",
        palette="Blues",
        border.lwds = "white"
        )
```

```{r}
d3tree(it, rootname = "Distribution of hscode")
```

::: {.callout-note title="Note about Treemap" collapse="true"}
## Note about Treemap

`index` vector shows the hscode code followed by the year.

`vSize` vector shows the distribution by weight(the size of the rectangles)

`vColor` vector shows the different intensity by median_weight

`type` vector reflects the value type treemap

`algorithm` vector to pivot by size

`sortID` vector to determined the order from top left to bottom right

`palette` vector paints the treemap using `[rColorBrewer]` package

`border.lwds` vector paints the border width to white
:::

**Observations:**

-   As observed from top left to bottom right, `hscode '306170'` has the highest transactions count along with higher than average median weight.

-   HS code that start with `30` occupies a higher weightage than the combined of code. It is composed fo six digits and could be broken down into chapter/heading/subheading with two digits each. From the graph above, hscode `306170` and `304620` are rank top and sixth position.

-   `hscode '870323` has the darkest gradient in 2032. As observed in section 4.1, the transactions count did not increase. Thus, it would be ideal to observed the transactions of `hscode 870323` in year 2032.

## Network graph for Hscode (306170)

```{r}

```

## Network graph for Hscode and year

```{r}
#| code-fold: true

#create edges df for transactions from Mar 2030
MC2_2032_870323_edges <- MC2_challenge_edges %>%
  filter(year == "2032" & hscode =="870323") %>%
  group_by(source, target, hscode) %>%
  summarize(weight = n()) %>%
  filter(source !=target) %>%
  filter(weight >1) %>% #keep ~200 rows 
  rename(from = source, to = target) %>%
  select(1,2,4,3) %>% #relocate weight to 3rd column 
  ungroup()

#create nodes df for transactions from Mar 2030
MC2_2032_870323_nodes <- MC2_id_list_vis %>%
  filter(id %in% MC2_2032_870323_edges$from | id %in% MC2_2032_870323_edges$to) %>%
  distinct() 

#create igraph object 
gg <- graph_from_data_frame(d=MC2_2032_870323_edges, 
                           vertices=MC2_2032_870323_nodes, directed=TRUE) 

#compute degree centrality 
degree_centrality <- degree(gg)
MC2_2032_870323_nodes$degree_centrality <- 
  degree_centrality[as.character(MC2_2032_870323_nodes$id)]

#add diverging palettes scheme to nodes based on degree centrality
colors <- colorRampPalette(brewer.pal(3, "RdYlBu"))(3) # use three colors 
MC2_2032_870323_nodes <- MC2_2032_870323_nodes %>%
  mutate(shape="dot", shadow=TRUE,  
         title=trade_status, # hover for trade_status
         label=label, # add labels on nodes
         size=20, # set size of nodes
         borderWidth=1, #set border width of nodes
         color.background=colors[degree_centrality], #set color for nodes
         color.border="grey") #set color for border

#plot network graph 
visNetwork(MC2_2032_870323_nodes, MC2_2032_870323_edges, main ="Trade flow in 2032
           <br>for hscode 870323<br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
    visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE,
             selectedBy = "degree_centrality") %>%
  visLegend() %>%
  visEdges(arrows = "to") %>% #indicate direction 
  visLayout(randomSeed = 123) %>%
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

## Statistical Plot of HScode against Years

```{r}
#| code-fold: true
MC2_challenge_edges_hscode <- MC2_challenge_edges %>%
  filter(hscode == "306170" | hscode == "950300" | hscode =="870899" |
         hscode == "940360" |hscode == "611020")

ggbarstats(data = MC2_challenge_edges_hscode, 
           x = hscode, y = year,
           xlab= "Year", ylab = "hscode",
           title = "Comparison of HScode across the Years",
           type = "nonparametric", conf.level = 0.95
           )
```

## Data Preparation for visNetwork

### TOP 30 SOURCE AND TOP 30 TARGET

```{r}
#| code-fold: true

#filter for top 30 source 
MC2_challenge_source <- MC2_challenge_edges %>%
  group_by(sourcelabel) %>%
  summarise(weight =n()) %>%
  arrange(desc(weight)) %>%
  top_n(30,weight)

#filter for top 30 target
MC2_challenge_target <- MC2_challenge_edges %>%
  group_by(targetlabel) %>%
  summarise(weight =n()) %>%
  arrange(desc(weight)) %>%
  top_n(30,weight)

#filter edges for transactions in top 30 source and top 30 target 
revisedlist <- MC2_challenge_edges%>%
  filter(sourcelabel %in% MC2_challenge_source$sourcelabel) %>%
  filter(targetlabel %in% MC2_challenge_target$targetlabel) 

#filter out nodes that are in top 30 source and top 30 target 
check_id_vis <- MC2_id_list_vis %>%
  filter(label %in% revisedlist$sourcelabel | 
           label %in% revisedlist$targetlabel) %>%
    rename(group = rcvcountry)

#aggregate by weight and rename to ensure that it                                         has id in nodes and from and to column in edges 
MC2_agg_rev <- revisedlist %>%
  left_join(check_id_vis, by = c("sourcelabel" = "label")) %>%
  rename(from = id) %>%
  left_join(check_id_vis, by = c("targetlabel" = "label")) %>%
  rename(to = id) %>%
  group_by(from, to) %>%
    summarise(weight = n()) %>%
  filter(from!=to) %>%
  filter(weight > 1) %>%
  ungroup()

```

```{r}
#| code-fold: true

visNetwork(check_id_vis, MC2_agg_rev, main ="Top 30 source/targets 
           <br>by receiving country<br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
    visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE,
              selectedBy="group") %>%
  visLegend() %>%
  visEdges(arrows = "to") %>% #indicate direction 
  visLayout(randomSeed = 123) %>%
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  visNodes(shape = "icon", icon= list(code ="f21a", color = "#3B9AB2" )) %>% 
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

## filter unknown status

```{r}
#| code-fold: true

#create df to filter list of unknown parties 
unknownMC2_nodes <- MC2_id_list_vis %>%
  filter(trade_status == "Unknown") %>%
  select(1:2)

#create df to filter list of exporters who solely do export or both 
MC2_exporters <- MC2_id_list_vis %>%
  filter(trade_status == "Export" | trade_status == "Import & Export")

#append by matching exporters to the importers (list of unknown)
unknownMC2 <- MC2_challenge_edges %>%
  left_join(MC2_exporters, by = c("sourcelabel" = "label")) %>%
  rename(from = id) %>%
  left_join(unknownMC2_nodes, by = c("targetlabel" = "label")) %>%
  rename(to = id) %>%
  filter (!is.na(to)) %>%
  group_by(from,to) %>%
    summarise(weight = n()) %>%
  filter (weight >1) %>%
    ungroup()

unknownMC2_revnodes <- MC2_id_list_vis %>%
  filter(id %in% unknownMC2$from | id %in% unknownMC2$to) %>%
  distinct() %>%
  select(1:3) %>%
  rename(group = trade_status)
```

Incorporate icons for node sharps from Font Awesome. Add in `addFontAwesome()` function and modify the shape and icon arguments to `VisNodes()`. Moreover, custom navigation have been included with the feature to zoomView, dragView.

```{r}
#| code-fold: true
#create network diagram for exporters
visNetwork(unknownMC2_revnodes, unknownMC2, 
           main = "Exporters who ship to <br> Unknown Origin<br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE) %>%
  visLayout (randomSeed = 123) %>% 
  visEdges(arrows = "to") %>% #indicate direction 
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  #fill color and shape
  visGroups(groupname = "Unknown", shape = "icon", 
            icon= list(code ="f21a", color = "#E1AF00" )) %>% 
  visGroups(groupname = "Import & Export", shape = "icon", 
            icon= list(code ="f21a", color = "#3B9AB2" )) %>% 
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

Based on the network above, there are 3 companies who supply to more than 1 unknown organization.

\~Hai Dan Corporation Wharf (deliver to 5 Unknown Status) \~Sailors and Surfers Incorporated Enterprises (deliver to 3 Unknown Status) \~Mar del Este CJSC (deliver to 3 Unknown Status )

# filter for companies with duplicated entries

```{r}
#detect duplicate rows and aggregate it 
MC2_dup_rows <- MC2_challenge_edges[duplicated(MC2_challenge_edges),] %>%
  rename(from = source) %>%
  rename(to = target) %>%
  group_by(from,to) %>%
    summarise(weight = n()) %>%
  filter (weight >1) %>%
  ungroup()

MC2_dup_top10 <- MC2_dup_rows %>%
    top_n(10,weight) 

#create df with corresponding nodes 
MC2_dup_nodes <- MC2_id_list_vis %>%
  filter(id %in% MC2_dup_top10$from | id %in% MC2_dup_top10$to) %>%
  distinct() %>%
  select(1:3) %>%
  rename(group = trade_status)

```

There are approximately 32% duplicated rows in the trade data.

```{r}
#| code-fold: true
#create network diagram for exporters
visNetwork(MC2_dup_nodes, MC2_dup_top10, 
           main = "Trade Transactions with  <br> Top 10 duplicates <br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE) %>%
  visLayout (randomSeed = 123) %>% 
  visEdges(arrows = "to") %>% #indicate direction 
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  #fill color and shape
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

```{r}
#check for duplicates 
dup <- (nrow(MC2_challenge_edges) - nrow(unique(MC2_challenge_edges)))
#reformat output 
dup_reformat <- format(dup, big.mark=",")
#print output
dup_reformat
```

# References:

https://vast-challenge.github.io/2023/MC2.html

https://www.nagraj.net/notes/visnetwork/

https://cran.r-project.org/web/packages/visNetwork/vignettes/Introduction-to-visNetwork.html

https://jtr13.github.io/cc21fall2/network-visualization-in-r.html

https://r-graph-gallery.com/38-rcolorbrewers-palettes.html

https://jtr13.github.io/cc21fall2/network-visualization-in-r.html#centrality-measurement
