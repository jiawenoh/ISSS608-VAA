---
title: "Take Home Exercise 2"
subtitle: " Mini Case 2 of Vast Challenge 2023"
author: "Oh Jia Wen"
date: "5/24/2023"
date-modified: "5/24/2023"
execute: 
  echo: true
  eval: true
  warning: false
---

# 1. OVERVIEW

FishEye International is collaborating with the country of Oceanus to identify companies who could potentially engaged in illegal, unreported, and unregulated (IUU) fishing. FishEye has transformed import/export data into a knowledge graph.

The country of Oceanus has sought FishEye International's help in identifying companies possibly engaged in illegal, unreported, and unregulated (IUU) fishing.

With reference to [Mini-Challenge 2](https://vast-challenge.github.io/2023/MC2.html) of [VAST Challenge 2023](https://vast-challenge.github.io/2023/) and by using appropriate **static and interactive statistical graphics** methods, you are required to help FishEye identify companies that may be engaged in illegal fishing?

## 1.1 The Task

In this take-home exercise...

# 2. Datasets

The trade data is stored in *mc2_challenge_graph.json* file with a time period of 7 years from the time period 2028 to 2024. It includes a bundles with 12 types of marine species, ranging from Carp, Shark, to Tuna.

# 3. Data Preparation

## 3.1 Install R-packages

Using p_load() of pacman package to load and install the following libraries:

-   `jsonlite` : To Import Data from JSON File into R

-   `lubridate` : To Convert Date and Time

-   `visNetwork`: For Network Visualization

-   `tidyverse`: A collection of R packages use in everyday data analyses. It is able to support data science, data wrangling, and analysis.

-   `ggplot2`:By

-   `hrbrthemes`: For Additional Themes, and Utilities for 'ggplot2'

-   `heatmaply`:

-   `treemap`:

-   `devtools`: For the installing for `d3treeR`

`igraph`: for exploring the network

`scales` : check at EOD

```{r}
pacman :: p_load (jsonlite, lubridate, tidygraph, ggraph, visNetwork, tidyverse,
                  igraph,ggplot2,heatmaply,hrbrthemes,scales,treemap,devtools)

options(scipen = 999)
```

## 3.2 Importing Data

There are 13 JSON files that will be imported into R the `fromJSON` function from `jsonlite`. The code chunk below shows the knowledge graph FishEye created from trade records.

```{r}
MC2_challenge <- fromJSON("data/mc2_challenge_graph.json")
```

```{r}
#| code-fold: true
MC2_carp <- fromJSON("data/bundles/carp.json")
MC2_catfish <- fromJSON("data/bundles/catfish.json")
MC2_chub_mackerel <- fromJSON("data/bundles/chub_mackerel.json")
MC2_cod2 <- fromJSON("data/bundles/cod2.json")
MC2_herring <- fromJSON("data/bundles/herring.json")
MC2_lichen <- fromJSON("data/bundles/lichen.json")
MC2_mackerel <- fromJSON("data/bundles/mackerel.json")
MC2_pollock <- fromJSON("data/bundles/pollock.json")
MC2_salmon_wgl <- fromJSON("data/bundles/salmon_wgl.json")
MC2_salmon <- fromJSON("data/bundles/salmon.json")
MC2_shark <- fromJSON("data/bundles/shark.json")
MC2_tuna <- fromJSON("data/bundles/tuna.json")
```

## 3.3 Create Tibble Dataframe

```{r}
MC2_challenge_nodes <-as_tibble(MC2_challenge$nodes) %>%
  select(id,shpcountry,rcvcountry)
MC2_challenge_edges <-as_tibble(MC2_challenge$links) %>%
  select(source,target,arrivaldate, hscode,valueofgoods_omu, 
         volumeteu, weightkg, valueofgoodsusd)
```

```{r}
#| code-fold: true

#1_fish type :carp
MC2_carp_nodes <-as_tibble(MC2_carp$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_carp_edges <-as_tibble(MC2_carp$links) %>%
  relocate(8,9,7,6)

#2_fish type: catfish
MC2_catfish_nodes <-as_tibble(MC2_catfish$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_catfish_edges <-as_tibble(MC2_catfish$links) %>%
  relocate(6,7,5,4)

#3_fish type: chub_mackerel
MC2_chub_mackerel_nodes <-as_tibble(MC2_chub_mackerel$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_chub_mackerel_edges <-as_tibble(MC2_chub_mackerel$links) %>%
  relocate(8,9,7,6)

#4_fish type: cod2
MC2_cod2_nodes <-as_tibble(MC2_cod2$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_cod2_edges <-as_tibble(MC2_cod2$links) %>%
  relocate(8,9,7,6)

#5_fish type: herring
MC2_herring_nodes <-as_tibble(MC2_herring$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_herring_edges <-as_tibble(MC2_herring$links) %>%
  relocate(7,8,6,5,1,2,9,3,4)

#6_fish type: lichen
MC2_lichen_nodes <-as_tibble(MC2_lichen$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_lichen_edges <-as_tibble(MC2_lichen$links) %>%
    relocate(7,8,6,5,1,2,9,3,4)

#7_fish type: mackerel
MC2_mackerel_nodes <-as_tibble(MC2_mackerel$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_mackerel_edges <-as_tibble(MC2_mackerel$links) %>%
    relocate(6,7,5,4)

#8_fish type: pollock
MC2_pollock_nodes <-as_tibble(MC2_pollock$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_pollock_edges <-as_tibble(MC2_pollock$links) %>%
    relocate(8,9,7,6)

#9_fish type: salmon_wgl
MC2_salmon_wgl_nodes <-as_tibble(MC2_salmon_wgl$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_salmon_wgl_edges <-as_tibble(MC2_salmon_wgl$links) %>%
  relocate(7,8,6,5,1,2,9,3,4)

#10_fish type: salmon
MC2_salmon_nodes <-as_tibble(MC2_salmon$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_salmon_edges <-as_tibble(MC2_salmon$links) %>%
  relocate(8,9,7,6)

#11_fish type: shark
MC2_shark_nodes <-as_tibble(MC2_shark$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_shark_edges <-as_tibble(MC2_shark$links) %>%
    relocate(7,8,6,5,1,2,9,3,4)

#12_fish type: tuna
MC2_tuna_nodes <-as_tibble(MC2_tuna$nodes) %>%
  select(id,dataset,shpcountry,rcvcountry)
MC2_tuna_edges <-as_tibble(MC2_tuna$links) %>%
  relocate(5,6,4,3)
```

## 3.4 Concatenate Tibble Dataframe

Among the 12 files, there are 3 data frames which have 7 variables whereas the rest have 9 variables. As such, `bind_rows()` - a function from the `dplyr` package within the `tidyverse` is used.

```{r}
combined_edges <- bind_rows(MC2_carp_edges,MC2_chub_mackerel_edges,
                        MC2_cod2_edges,MC2_herring_edges,MC2_lichen_edges,
                        MC2_pollock_edges,MC2_salmon_wgl_edges,
                        MC2_salmon_edges,MC2_shark_edges, 
                        MC2_catfish_edges,MC2_mackerel_edges,MC2_tuna_edges)
```

::: callout-Tip
Catfish, Mackerel, and Tuna have 7 variables while other fishes have 9 variables. It is better to concatenate with the use `blind_rows` instead of `rbind()` as the latter requires an exact match in the numbers of columns.
:::

```{r}
combined_nodes <- bind_rows(MC2_carp_nodes,MC2_catfish_nodes,
                            MC2_chub_mackerel_nodes,MC2_cod2_nodes,
                            MC2_herring_nodes, MC2_lichen_nodes,
                            MC2_mackerel_nodes, MC2_pollock_nodes, 
                            MC2_salmon_wgl_nodes,MC2_salmon_nodes,
                            MC2_shark_nodes, MC2_tuna_nodes)
```

## Creating a Master ID data frame

```{r}
MC2_id_list <- MC2_challenge_nodes %>%
  rename(label = id) %>%
  mutate(
    trade_status = case_when(
    !is.na(shpcountry) & !is.na(rcvcountry) ~ "Import & Export",
    !is.na(shpcountry) ~ "Export",
    !is.na(rcvcountry) ~ "Import",
    is.na(shpcountry) | is.na(rcvcountry) ~"Unknown"
  )) 

MC2_id_list <- MC2_id_list %>%
  select(label,trade_status,shpcountry, rcvcountry)

#master ID list for visNetwork 
MC2_id_list_vis <- MC2_challenge_nodes %>%
  rename(label = id) %>%
  mutate(id = as.character(1:nrow(MC2_challenge_nodes)),
    trade_status = case_when(
    !is.na(shpcountry) & !is.na(rcvcountry) ~ "Import & Export",
    !is.na(shpcountry) ~ "Export",
    !is.na(rcvcountry) ~ "Import",
    is.na(shpcountry) | is.na(rcvcountry) ~"Unknown"
  )) %>%
  filter(!is.na(trade_status))

MC2_id_list_vis <- MC2_id_list_vis %>%
  select(id,label, trade_status,shpcountry, rcvcountry)
```

```{r}
#create df to identify companies in target column that are not in the nodes 
ID_target <- MC2_challenge_edges %>%
  filter(!(target %in% MC2_id_list$label)) %>%
  distinct(target) %>%
  #rename to match names in nodes df
  rename(id = target) %>%
  #dummy columns are created to bind rows together
  mutate(dataset = NA, shpcountry = NA, rcvcountry = NA)

#create df to identify companies in source column that are not in the nodes 
ID_source <- MC2_challenge_edges %>%
  filter(!(source %in% MC2_id_list$label)) %>%
  distinct(source) %>%
  rename(id = source) %>%
  mutate(dataset = NA, shpcountry = NA, rcvcountry = NA)

#append the distinct companies into the nodes 
MC2_challenge_nodes <- MC2_challenge_nodes %>%
  rbind(ID_target) %>%
  rbind(ID_source)

#output of ID nodes that are not in Master list
nrow(ID_source)
nrow(ID_target)
```

There are 0 companies on the `target` column that are not included in the list. Meanwhile, there are no data available in the `source` column that are not in the list.

The `!is.na()` functions help to check for non-missing values in the specified column. In this combined_nodes data frame, the ID only corresponds to either the shipping country or the receiving country. Therefore, it is further segregated into import and export.

```{r}
any(is.na(MC2_id_list))
```

## 3.5 Data Wrangling

```{r}
#| code-fold: true

#revise the data format for arrivaldate and hscode 
MC2_challenge_edges<- MC2_challenge_edges %>%
  rename(sourcelabel = source, targetlabel = target) %>%
  mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode),
         year = year(arrivaldate))

#to append correspoinding id through left_join 
MC2_challenge_edges <- MC2_challenge_edges %>%
  left_join(MC2_id_list_vis, by = c("sourcelabel" = "label")) %>%
  rename(source = id) %>%
  left_join(MC2_id_list_vis, by = c("targetlabel" = "label")) %>%
  rename(target = id) %>%
  relocate(10,14)
  
```

```{r}
combined_edges_cleaned<- combined_edges %>%
  mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

combined_edges_cleaned
```

#### 3.5.1 Data Wrangling for Bundles

```{r}
#| code-fold: true

#1_fish type: carp
MC2_carp_edges_cleaned <- MC2_carp_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#2_fish type: catfish
MC2_catfish_edges_cleaned <- MC2_catfish_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#3_fish type: chub_mackerel
MC2_chub_mackerel_edges_cleaned <- MC2_chub_mackerel_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#4_fish type: cod2
MC2_cod2_edges_cleaned <- MC2_cod2_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#5_fish type: herring
MC2_herring_edges_cleaned <- MC2_herring_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#6_fish type: lichen
MC2_lichen_edges_cleaned <- MC2_lichen_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#7_fish type: mackerel
MC2_mackerel_edges_cleaned <- MC2_mackerel_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))
#8_fish type: pollock
MC2_pollock_edges_cleaned <- MC2_pollock_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#9_fish type: salmon_wgl
MC2_salmon_wgl_edges_cleaned <- MC2_salmon_wgl_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#10_fish type: salmon
MC2_salmon_edges_cleaned <- MC2_salmon_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#11_fish type: shark
MC2_shark_edges_cleaned <- MC2_shark_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))

#12_fish type: tuna
MC2_tuna_edges_cleaned <- MC2_tuna_edges %>%
    mutate(arrivaldate =ymd(arrivaldate),
         hscode = as.character(hscode))
```

::: {.callout-caution title="Important"}
HS code, also known as The Harmonized System are alphanumeric codes used for classifying goods for international trade and customs purposes. In this exercise, the HS code does not correspond to the respective goods.
:::

Weights: Median = 2 , Mean = 22 , Min = 1, Max, 47134

```{r}
combined_edges_rev <- combined_edges %>%
  group_by(source,target,generated_by) %>%
  summarize(weight = n()) %>%
  filter( source!=target) %>%
  filter(weight >1) %>%
  ungroup ()
```

```{r}
combined_nodes_rev <-MC2_id_list %>%
  filter(label %in% combined_edges_rev$source | 
           label %in% combined_edges_rev$target)
```

```{r}
MC2_import <- tbl_graph(nodes = combined_nodes_rev,
                        edges = combined_edges_rev,
                        directed = TRUE)

MC2_import
```

```{r}
MC2_import %>%
  activate(edges) %>%
  arrange(desc(weight))
```

```{r}
set_graph_style()

fishes <- ggraph(MC2_import, layout = "nicely") +
  geom_node_point(aes(color = trade_status), size =2) +
  scale_edge_width(range =c(0.1,5)) +
  geom_edge_link(aes(width = weight, color = generated_by), alpha = 0.2)

fishes
```

# Distribution of transactions

## Number of Transactions by Year and Month

with `ggplotly`

`scale_fill_distiller` to provide a ColorBrewer palette. Sequential palettes (first list of colors), which are suited to ordered data that progress from low to high (gradient). The palettes names are : Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu YlOrBr, YlOrRd.

```{r}
#| code-fold: true

transaction_counts_by_year <- MC2_challenge_edges %>%
  mutate(month = round(month(arrivaldate))) %>%
  group_by(year,month) %>%
  summarise(count = n())

heatmap <- ggplot(transaction_counts_by_year, 
                  aes(x = year, y = month, fill = count)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdBu") +
  theme_ipsum() +
  labs(x = "Year", y = "Month", title = "Number of Transactions by Year and Month") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  scale_y_continuous(breaks = 1:12) +
  scale_x_continuous(breaks = 2028:2034)

ggplotly(heatmap)
```

```{r}
#| code-fold: true

#aggregate to determine transactions count by year and month 
transaction_counts_by_year <- MC2_challenge_edges %>%
  mutate(month = round(month(arrivaldate))) %>%
  group_by(year, month) %>%
  summarise(count = n())

#transpose df by using pivot_wider
pivoted_data <- transaction_counts_by_year %>%
  pivot_wider(names_from = year, values_from = count) %>%
  #remove the month column
  select(2:8)

#convert pivoted_data into a matrix
heatmap_data <- as.matrix(pivoted_data)

#create interactive heatmap without dendrogram
heatmaply(heatmap_data, dendrogram = "none",
          xlab = "Year", ylab = "Month",
          main = "Number of Transactions by Year and Month",
          scale = "none",
          grid_color = "white",
          grid_width = 0.00001,
          titleX = FALSE,
          hide_colorbar =  FALSE,
          label_names = c("Month:", "Year: ", "No. of Transactions:"),
          fontsize_row = 10, fontsize_col = 10,
          colors = "Blues",
          labCol = colnames(heatmap_data),
          labRow = rownames(heatmap_data),
          plot_method = "plotly")
```

### **Trade flow of Organizations with above 30 transactions in Mar 2023**

`graph_from_data_frame` function from `[igraph]` package is used to compute the centrality between the nodes.

```{r}
#| code-fold: true

#create edges df for transactions from Mar 2030
MC2_2030_Mar_edges <- MC2_challenge_edges %>%
  mutate(month = round(month(arrivaldate))) %>%
  filter(year == "2030" & month =="3") %>%
  group_by(source, target, hscode) %>%
  summarize(weight = n()) %>%
  filter(source !=target) %>%
  filter(weight >29) %>% #keep ~200 rows 
  rename(from = source, to = target) %>%
  select(1,2,4,3) %>% #relocate weight to 3rd column 
  ungroup()

#create nodes df for transactions from Mar 2030
MC2_2030_Mar_nodes <- MC2_id_list_vis %>%
  filter(id %in% MC2_2030_Mar_edges$from | id %in% MC2_2030_Mar_edges$to) %>%
  distinct() 

#create igraph object 
g <- graph_from_data_frame(d=MC2_2030_Mar_edges, 
                           vertices=MC2_2030_Mar_nodes, directed=TRUE) 
```

```{r}
#compute betweeness centrality 
betweenness_centrality <- betweenness(g)
MC2_2030_Mar_nodes$betweenness_centrality <-
  betweenness_centrality[as.character(MC2_2030_Mar_nodes$id)]
head(sort(betweenness_centrality, decreasing=TRUE))
```

```{r}
#| code-fold: true

#compute degree centrality 
degree_centrality <- degree(g)
MC2_2030_Mar_nodes$degree_centrality <- 
  degree_centrality[as.character(MC2_2030_Mar_nodes$id)]
head(sort(degree_centrality, decreasing=TRUE))

#compute closeness centrality 
closeness_centrality <- closeness(g, normalized=TRUE)
MC2_2030_Mar_nodes$closeness_centrality <- 
  closeness_centrality[as.character(MC2_2030_Mar_nodes$id)]
head(sort(closeness_centrality, decreasing=TRUE))

#plot network graph 
visNetwork(MC2_2030_Mar_nodes, MC2_2030_Mar_edges, main ="Trade flow of Organizations  
           <br>with above 30 transactions in Mar 2023<br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
    visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE,
              selectedBy ="degree_centrality") %>%
  visLegend() %>%
  visEdges(arrows = "to") %>% #indicate direction 
  visLayout(randomSeed = 123) %>%
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  visNodes(shape = "icon", icon= list(code ="f21a", color = "#3B9AB2" )) %>% 
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

## Distribution of Median Weight by hscode and year

A `treemap` displays hierarchical data as a set of nested rectangles, where each group is represented by an area that it proportional to its value. We would like to examine the distribution by **hscode** and **year.** The `[devtools]` package have been loaded in section 3.1. Thereafter, we install the package found in github *(highlighted in green)* by using the code and loading the `d3treeR` package.

```{r}
#install_github("timelyportfolio/d3treeR")
library(d3treeR)
```

We will aggregate from `MC2_challenge_edges` data frame by using the `[dpylr]` package:

-   `group_by` is used to aggregate it by **hscode** and **year**

-   `summarize()` is used to compute the **weight** and **median_weight** of goods

-   `arrange(desc())` to sort weight in descending order

-   `MC2_hscode_weight[1:100,]` to retrieve the first 100 rows

*(We are only interested in the highly utilized hscode)*

We build our treemap by inputting our aggregated data frame (`MC2_hscode_weight`) into the `treemap()` function and saved it as an object called **it.** Thereafter, the `d3tree` function from the `[d3treeR]` package is used to build our interactive treemap.

```{r}
#| code-fold: true
#| fig-width: 12
#| fig-height: 6
#| echo: false

#aggregate into new df by hscode and year before sorting in descending order 
MC2_hscode_weight <- MC2_challenge_edges %>%
  group_by(hscode,year) %>%
  summarize(weight = n(),
            median_weight = median(weightkg)) %>%
  arrange(desc(weight)) 

#retrieve the first 100 rows
MC2_hscode_weight <- MC2_hscode_weight[1:100,]

#treemap saved under 'it' object 
it <- treemap(MC2_hscode_weight,
        index=c("hscode","year"),
        vSize="weight",
        vColor="median_weight",
        type ="value",
        algorithm = "pivotSize",
        sortID = "weight",
        palette="Blues",
        border.lwds = "white"
        )
```

```{r}
d3tree(it, rootname = "Distribution of hscode")
```

::: {.callout-note title="Note about Treemap" collapse="true"}
## Note about Treemap

`index` vector shows the hscode code followed by the year.

`vSize` vector shows the distribution by weight(the size of the rectangles)

`vColor` vector shows the different intensity by median_weight

`type` vector reflects the value type treemap

`algorithm` vector to pivot by size

`sortID` vector to determined the order from top left to bottom right

`palette` vector paints the treemap using `[rColorBrewer]` package

`border.lwds` vector paints the border width to white
:::

## Data Preparation for visNetwork

### TOP 30 SOURCE AND TOP 30 TARGET

```{r}
#| code-fold: true

#filter for top 30 source 
MC2_challenge_source <- MC2_challenge_edges %>%
  group_by(sourcelabel) %>%
  summarise(weight =n()) %>%
  arrange(desc(weight)) %>%
  top_n(30,weight)

#filter for top 30 target
MC2_challenge_target <- MC2_challenge_edges %>%
  group_by(targetlabel) %>%
  summarise(weight =n()) %>%
  arrange(desc(weight)) %>%
  top_n(30,weight)

#filter edges for transactions in top 30 source and top 30 target 
revisedlist <- MC2_challenge_edges%>%
  filter(sourcelabel %in% MC2_challenge_source$sourcelabel) %>%
  filter(targetlabel %in% MC2_challenge_target$targetlabel) 

#filter out nodes that are in top 30 source and top 30 target 
check_id_vis <- MC2_id_list_vis %>%
  filter(label %in% revisedlist$sourcelabel | 
           label %in% revisedlist$targetlabel) %>%
    rename(group = rcvcountry)

#aggregate by weight and rename to ensure that it                                         has id in nodes and from and to column in edges 
MC2_agg_rev <- revisedlist %>%
  left_join(check_id_vis, by = c("sourcelabel" = "label")) %>%
  rename(from = id) %>%
  left_join(check_id_vis, by = c("targetlabel" = "label")) %>%
  rename(to = id) %>%
  group_by(from, to) %>%
    summarise(weight = n()) %>%
  filter(from!=to) %>%
  filter(weight > 1) %>%
  ungroup()

```

```{r}
#| code-fold: true

visNetwork(check_id_vis, MC2_agg_rev, main ="Top 30 source/targets 
           <br>by receiving country<br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
    visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE,
              selectedBy="group") %>%
  visLegend() %>%
  visEdges(arrows = "to") %>% #indicate direction 
  visLayout(randomSeed = 123) %>%
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  visNodes(shape = "icon", icon= list(code ="f21a", color = "#3B9AB2" )) %>% 
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

```{r}
top30_snt <- tbl_graph(nodes = check_id_vis,
                       edges = MC2_agg_rev,
                       directed = TRUE)

top30_snt %>%
  activate(edges) %>%
  arrange(desc(weight))
```

```{r}
snt <- top30_snt %>%
  mutate(betweenness_centrality = centrality_betweenness()) %>%
  ggraph(layout = "fr") +
  geom_edge_link(aes(width = weight), alpha = 0.2) +
  scale_edge_width(range =c(0.1,5)) +
  geom_node_point(aes(size=betweenness_centrality))

snt + theme_graph()
```

## filter unknown status

```{r}
#| code-fold: true

#create df to filter list of unknown parties 
unknownMC2_nodes <- MC2_id_list_vis %>%
  filter(trade_status == "Unknown") %>%
  select(1:2)

#create df to filter list of exporters who solely do export or both 
MC2_exporters <- MC2_id_list_vis %>%
  filter(trade_status == "Export" | trade_status == "Import & Export")

#append by matching exporters to the importers (list of unknown)
unknownMC2 <- MC2_challenge_edges %>%
  left_join(MC2_exporters, by = c("sourcelabel" = "label")) %>%
  rename(from = id) %>%
  left_join(unknownMC2_nodes, by = c("targetlabel" = "label")) %>%
  rename(to = id) %>%
  filter (!is.na(to)) %>%
  group_by(from,to) %>%
    summarise(weight = n()) %>%
  filter (weight >1) %>%
    ungroup()

unknownMC2_revnodes <- MC2_id_list_vis %>%
  filter(id %in% unknownMC2$from | id %in% unknownMC2$to) %>%
  distinct() %>%
  select(1:3) %>%
  rename(group = trade_status)
```

Incorporate icons for node sharps from Font Awesome. Add in `addFontAwesome()` function and modify the shape and icon arguments to `VisNodes()`. Moreover, custom navigation have been included with the feature to zoomView, dragView.

```{r}
#| code-fold: true
#create network diagram for exporters
visNetwork(unknownMC2_revnodes, unknownMC2, 
           main = "Exporters who ship to <br> Unknown Origin<br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE) %>%
  visLayout (randomSeed = 123) %>% 
  visEdges(arrows = "to") %>% #indicate direction 
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  #fill color and shape
  visGroups(groupname = "Unknown", shape = "icon", 
            icon= list(code ="f21a", color = "#E1AF00" )) %>% 
  visGroups(groupname = "Import & Export", shape = "icon", 
            icon= list(code ="f21a", color = "#3B9AB2" )) %>% 
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

Based on the network above, there are 3 companies who supply to more than 1 unknown organization.

\~Hai Dan Corporation Wharf (deliver to 5 Unknown Status) \~Sailors and Surfers Incorporated Enterprises (deliver to 3 Unknown Status) \~Mar del Este CJSC (deliver to 3 Unknown Status )

# filter for companies with duplicated entries

```{r}
#detect duplicate rows and aggregate it 
MC2_dup_rows <- MC2_challenge_edges[duplicated(MC2_challenge_edges),] %>%
  rename(from = source) %>%
  rename(to = target) %>%
  group_by(from,to) %>%
    summarise(weight = n()) %>%
  filter (weight >1) %>%
  ungroup()

MC2_dup_top10 <- MC2_dup_rows %>%
    top_n(10,weight) 

#create df with corresponding nodes 
MC2_dup_nodes <- MC2_id_list_vis %>%
  filter(id %in% MC2_dup_top10$from | id %in% MC2_dup_top10$to) %>%
  distinct() %>%
  select(1:3) %>%
  rename(group = trade_status)

```

There are approximately 32% duplicated rows in the trade data.

```{r}
#| code-fold: true
#create network diagram for exporters
visNetwork(MC2_dup_nodes, MC2_dup_top10, 
           main = "Trade Transactions with  <br> Top 10 duplicates <br>") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visOptions(highlightNearest = TRUE,
             nodesIdSelection = TRUE) %>%
  visLayout (randomSeed = 123) %>% 
  visEdges(arrows = "to") %>% #indicate direction 
  addFontAwesome(name = "font-awesome") %>% #add icon to network 
  #fill color and shape
  visLegend() %>%
  visInteraction(dragNodes = FALSE, dragView = TRUE, 
                 zoomView = TRUE, navigationButtons = TRUE) #freeze network
```

```{r}
#check for duplicates 
dup <- (nrow(MC2_challenge_edges) - nrow(unique(MC2_challenge_edges)))
#reformat output 
dup_reformat <- format(dup, big.mark=",")
#print output
dup_reformat
```

# References:

https://vast-challenge.github.io/2023/MC2.html

https://www.nagraj.net/notes/visnetwork/

https://cran.r-project.org/web/packages/visNetwork/vignettes/Introduction-to-visNetwork.html

https://jtr13.github.io/cc21fall2/network-visualization-in-r.html

https://r-graph-gallery.com/38-rcolorbrewers-palettes.html
